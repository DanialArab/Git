
# Creating Snapshots

## Introduction

The first thing to know to be able to use Git effectively is **creating snapshots** of your project. 

## Initializing a Git Repository

Some points on how to initialize a git repo:

+ First we create a directory for our project, which could be anywhere on our machine. 

+ I can create a git repository using **git init**

+ To open a .git: in the Git Bash terminal I need to type explorer .git and press enter, the files/folders that I find there in my git directory or repository are **config, HEAD, hooks, info, etc.** this is where Git stores information about my project’s history, I do NOT need to understand these details and structures because these are purely implementation details. It is how Git stores information it is none of our business:) That is why this .git directory is hidden so that we don’t touch it. If we corrupt or remove this directory we will lose our project’s history. 

+ In windows I can install posh-git to make thing pretty, it is completely optional.

## Git Workflow

We have a project directory in which we have a hidden subdirectory i.e., our .git repository. As part of our every day tasks we modify more and more files in our project directory, when our project reaches a state that we want to record we commit those changes into our repository. Creating a commit is like taking a snapshot of our project. In Git we have a special area called **staging area or index**, which does not exist in most other version control systems, we essentially propose what we want for the next commit or snapshot. 

When we are done making changes in our file in project directory we add them into the staging area for review and if everything is good then we make a commit then the snapshot will be permanently stored in our repository. So **staging area allows us to review our work before recording a snapshot.** If some of the changes should not be recorded as part of the next snapshot we can **un-stage them and commit them as part of another snapshot.**

Some points:

+ We use add command to add the files to the staging area like git add file1 file2 
+ We use the commit command to permanently store the snapshots in our repository like git commit –m “initial commit” as part of this we supply a meaningful message, initial commit in this example, to indicate what this snapshot represents this is essential for having a useful history (tips: 1- the dash m in the commit command is for message 2- if we have space in the message we need to have a double quote)
+ As we fix bugs, implement new features, and refactor our code we make commit and each commit clearly explains the state of the project at that point in time 
+	A common misconception about Git is that once we commit the changes the staging area becomes empty, which is not correct. After making a commit we still have the same snapshot as we stored in the repository so this staging area is very similar to the staging environment we use when releasing software to production. 
+ If we no longer need a file like file2 we can delete it from our project directory but this file is still in the staging area so once again we use **add command to stage the change**, which is in this case a deletion like **git add file2** here even though we use add command Git knows that file2 is actually deleted so it will delete this file from the staging area or the next snapshot

**Each commit has:**

+ ID, a unique identifier that is generated by Git it is like a revision number 
+ Each commit also has the following information
  + Message
  + Date/time
  + Author
  + Complete snapshot 

These are info about what was changed by who when as well as a complete snapshot of the project at the time it was created so unlike many other version control systems Git does not store deltas or what was changed, it stores the full content, with this we can quickly restore the project to an earlier snapshot without having to compute the changes 

**Question: is it waste of a lot of space when saving the full content in every snapshot?** NO, b/c Git is very efficient in data storage
+ it compresses the content and 
+	does not store the duplicate contents 

you don’t need to know how Git stores data since it is implementation detail and may even change in the future what you need to know is that **each commit contains a complete snapshot of our project and this allows us to quickly get back to the previous state.**

## Staging Files

Let's write something into two files:

    echo hello > file1.txt 
    echo hello > file2.txt 

git status

    On branch master

    No commits yet

    Untracked files:
      (use "git add <file>..." to include in what will be committed)
            file1.txt
            file2.txt

The two files are in red to indicate they are not in the staging area yet, to add them to the staging area we use **git add** command we can add multiple files separated by **space**, we also can use pattern like git add *.txt to add all the files with txt extension. We can also add the entire directory recursively using **git add .** but be careful b/c there are times that we don’t want to add **large binary files or log files to repository b/c they increase the size of the repository**, we will learn how to ignore these files later in this section. Just remember **git add .** add the entire directory recursively. Let's add the files into the staging area:

    git add .

    git status
    On branch master

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)
            new file:   file1.txt
            new file:   file2.txt

Now the two files are in green meaning they are in the staging area. If I modify file1 like

echo world >> file1.txt

    git status

    On branch master

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)
            new file:   file1.txt
            new file:   file2.txt

    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            modified:   file1.txt

Now, here we have two files in the staging area b/c they are in green, and we also have one modified file in our working directory now we have the first version of this file1 in the staging area but we changed it after adding it to the staging area so what we have in the working directory is the second version of this file, there are changes that are not staged yet so 

    git add file1.txt
    
    git status
    On branch master

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)
            new file:   file1.txt
            new file:   file2.txt

Now we have both files in the staging area without having any un-staged changes. Next we see how to commit a snapshot to permanently sore it in the repository. 

## Committing Changes

Now we have a snapshot in the staging area which is ready to be permanently stored in the repository:

    git commit -m "initial commit."

In case you want to add more details in the message (more than just “initial commit”, which is pretty useful to you and your coworkers), we just drop the message:

    git commit

When we press enter it opens up the default editor to open the following file name COMMIT_EDITMSG, which is stored in our git subdirectory: 

On the top we can add a short description, which should ideally be less than 80 characters, then we add a line break and after that we can add a long description:

    Initial commit.

    This is our first commit. 
    # Please enter the commit message for your changes. Lines starting
    # with '#' will be ignored, and an empty message aborts the commit.
    #
    # On branch master
    #
    # Initial commit
    #
    # Changes to be committed:
    #   new file:   file1.txt
    #   new file:   file2.txt
    #

After saving changes we close this file in the VS Code. Back to the terminal:

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/desktop/Moon (master)
    $ git commit
    [master (root-commit) 1d36677]  Initial commit.
     2 files changed, 3 insertions(+)
     create mode 100644 file1.txt
     create mode 100644 file2.txt

we had three insertion: 2 in file1 hello world and 1 in file2. Now what we have in our working directory is exactly the same content as we have in our staging area which is exactly the same content as we have in the last commit. 

##  Committing Best Practices

+ Commit size matters, your commit should not be too big or too small. 
+ The whole point of committing is to record check points as we go so it does not make sense to commit after three days of coding! We want always go back and recover our code if we screw up. 
+	So try to commit often, we commit often like 5 or 10 times a day but of course it depends on the type of work we do and this is just a number don’t take it as a rule. The best practice is to make a commit when you reach a state that you want to record 
+	Each commit should represent a logically separate chain set so don’t mix things up e.g., if you are fixing a bug and you accidentally find a typo in your code you should not commit both these changes in one commit you should have two separate commits one for bug fix and the other for typo, if you accidentally stage both these two changes you can easily un-stage them, will be discussed later. 
+	Have a habit of meaningful commit messages because all of these messages will be shown in history, if your messages are cryptic they will not be helpful to you and other team members, if you do too many things in one commit it will also be hard to have a meaningful message! 
+	In terms of wording in your commit messages, most people prefer to use present tense like “Fix the bug”, instead of “Fixed the bug” you can choose either but be consistent with other team members

## Skipping the Staging Area

Do we always have to stage our change before committing them? No, we can skip it **BUT** only do this if you really know what you are doing and you are 100% sure your code and changes don’t need to be reviewed. Just remember 99% of times you should always stage your changes before committing. 

    echo test >> file1.txt

    git status
    On branch master
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            modified:   file1.txt

    no changes added to commit (use "git add" and/or "git commit -a")

Here I will not use git add file1.txt to first stage the changes and instead straight I commit the changes like:

    git commit -am “Fixed the bugs that prevented users from signing in”. 

I could have done git commit -a -m"Fixed the bugs that prevent users from signing in"

## Removing files

If we want to delete a file which contains unused code, let’s say I have two files in my working directory and also in my staging area which are both committed:

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ cat file1.txt
    hello
    world
    worldi

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ cat file2.txt
    hello

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git status
    On branch master
    nothing to commit, working tree clean

To remove the file2.txt from the working directory I can do (of course rm is just a standard Linux command and not a git command since it does not start with git): 

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ rm file2.txt

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ ls
    file1.txt

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git status
    On branch master
    Changes not staged for commit:
      (use "git add/rm <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            deleted:    file2.txt
    no changes added to commit (use "git add" and/or "git commit -a")

here file2.txt is deleted from the working directory but **still exists in the staging area**, let me prove:

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git ls-files
    file1.txt
    file2.txt

but we had:

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ ls
    file1.txt

As discussed every time we have changes we have to stage those changes using **add** command, here the change is deletion, to stage this change:

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git add file2.txt

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git ls-files
    file1.txt

so file2.txt is no longer in the staging area. 

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git status
    On branch master
    Changes to be committed:
      (use "git restore --staged <file>..." to unstage)
            deleted:    file2.txt

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git commit -m "Remove unused code"
    [master bdfea43] Remove unused code
     1 file changed, 1 deletion(-)
     delete mode 100644 file2.txt

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git status
    On branch master
    nothing to commit, working tree clean

So remember to remove a file, we have to remove it both from our working directory and also from the staging area. Because it is a very common operation git gives us a command, **git rm**, which performs both steps in one go: 

    dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
    $ git rm file2.txt

## Renaming or moving files

Obvious Reminder: mv is a Linux command for moving and renaming files.

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ ls
  file1.txt

dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
$ mv file1.txt main.py

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git status
  On branch master
  Changes not staged for commit:
    (use "git add/rm <file>..." to update what will be committed)
    (use "git restore <file>..." to discard changes in working directory)
          deleted:    file1.txt

  Untracked files:
    (use "git add <file>..." to include in what will be committed)
          main.py

  no changes added to commit (use "git add" and/or "git commit -a")

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git add file1.txt

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git add main.py
  warning: in the working copy of 'main.py', LF will be replaced by CRLF the next time Git touches it

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git status
  On branch master
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          renamed:    file1.txt -> main.py


Indicated in green which means that this is in staging area. 
  
Renaming or moving files is a two-step operation: 
  
+ 1. First we have to modify our working directory 
+ 2. Then we have to stage two types of changes: a deletion and an addition 
  
Similar to removing files git gives us a special command, **git mv main.py main.js**, for renaming and moving files:
  
  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git mv main.py main.js

  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git status
  On branch master
  Changes to be committed:
    (use "git restore --staged <file>..." to unstage)
          renamed:    file1.txt -> main.js

When using git mv main.py main.js changes are applied to both working directory and staging area. 
  
  dania@DESKTOP-IQ7H5F1 MINGW64 ~/Desktop/Moon (master)
  $ git commit -m "Refactor code."
  [master 4096ae7] Refactor code.
   1 file changed, 0 insertions(+), 0 deletions(-)
   rename file1.txt => main.js (100%)

  ## Ignoring Files
